// Generated by: hibernate/SpringHibernateDaoImpl.vsl in andromda-spring-cartridge.
// This file is part of the Phoenix CTMS project (www.phoenixctms.org),
// distributed under LGPL v2.1. Copyright (C) 2011 - 2017.
/**
 * This is only generated once! It will never be overwritten.
 * You can (and have to!) safely modify it by hand.
 */
package org.phoenixctms.ctsms.domain;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

import javax.activation.DataHandler;
import javax.mail.Address;
import javax.mail.Message.RecipientType;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Part;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;

import org.hibernate.criterion.Conjunction;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.phoenixctms.ctsms.email.MassMailEmailSender;
import org.phoenixctms.ctsms.enumeration.FileModule;
import org.phoenixctms.ctsms.query.CriteriaUtil;
import org.phoenixctms.ctsms.query.SubCriteriaMap;
import org.phoenixctms.ctsms.security.CryptoUtil;
import org.phoenixctms.ctsms.security.reencrypt.DataReEncrypter;
import org.phoenixctms.ctsms.security.reencrypt.ReEncrypter;
import org.phoenixctms.ctsms.util.CommonUtil;
import org.phoenixctms.ctsms.util.CoreUtil;
import org.phoenixctms.ctsms.util.DefaultSettings;
import org.phoenixctms.ctsms.util.ServiceUtil;
import org.phoenixctms.ctsms.util.SettingCodes;
import org.phoenixctms.ctsms.util.Settings;
import org.phoenixctms.ctsms.util.Settings.Bundle;
import org.phoenixctms.ctsms.vo.EmailAddressVO;
import org.phoenixctms.ctsms.vo.EmailAttachmentVO;
import org.phoenixctms.ctsms.vo.EmailMessageVO;
import org.phoenixctms.ctsms.vo.MassMailOutVO;
import org.phoenixctms.ctsms.vo.MassMailRecipientInVO;
import org.phoenixctms.ctsms.vo.MassMailRecipientOutVO;
import org.phoenixctms.ctsms.vo.MimeTypeVO;
import org.phoenixctms.ctsms.vo.PSFVO;
import org.phoenixctms.ctsms.vo.ProbandOutVO;
import org.phoenixctms.ctsms.vo.UserOutVO;

/**
 * @see MassMailRecipient
 */
public class MassMailRecipientDaoImpl
		extends MassMailRecipientDaoBase {

	private static void applyPendingCriteria(org.hibernate.Criteria recipientCriteria, boolean not) {
		Conjunction criterions = Restrictions.conjunction();
		criterions.add(Restrictions.eq("sent", false));
		criterions.add(Restrictions.eq("cancelled", false));
		Long processMassMailsMax = Settings.getLongNullable(SettingCodes.EMAIL_PROCESS_MASS_MAILS_MAX, Bundle.SETTINGS, DefaultSettings.EMAIL_PROCESS_MASS_MAILS_MAX);
		if (processMassMailsMax != null) {
			criterions.add(Restrictions.lt("timesProcessed", processMassMailsMax.longValue()));
		}
		if (not) {
			recipientCriteria.add(Restrictions.not(criterions));
		} else {
			recipientCriteria.add(criterions);
		}
	}

	private static EmailAddressVO internetAddressToEmailAddressVO(InternetAddress address) {
		return new EmailAddressVO(address.getAddress(), address.getPersonal());
	}

	private final static Collection<ReEncrypter<MassMailRecipient>> RE_ENCRYPTERS = new ArrayList<ReEncrypter<MassMailRecipient>>();
	static {
		RE_ENCRYPTERS.add(new DataReEncrypter<MassMailRecipient>() {

			@Override
			protected byte[] getIv(MassMailRecipient item) {
				return item.getMimeMessageDataIv();
			}

			@Override
			protected byte[] getEncrypted(MassMailRecipient item) {
				return item.getEncryptedMimeMessageData();
			}

			@Override
			protected void setIv(MassMailRecipient item, byte[] iv) {
				item.setEncryptedMimeMessageData(iv);
			}

			@Override
			protected void setEncrypted(MassMailRecipient item, byte[] cipherText) {
				item.setEncryptedMimeMessageData(cipherText);
			}

			@Override
			protected boolean isSkip(MassMailRecipient item) {
				return item.getMimeMessageSize() == 0l;
			}
		});
	}

	@Override
	protected Collection<ReEncrypter<MassMailRecipient>> getReEncrypters() {
		return RE_ENCRYPTERS;
	}

	private MassMailEmailSender massMailEmailSender;

	private org.hibernate.Criteria createRecipientCriteria() {
		org.hibernate.Criteria recipientCriteria = this.getSession().createCriteria(MassMailRecipient.class);
		return recipientCriteria;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public MassMailRecipient emailMessageVOToEntity(EmailMessageVO emailMessageVO) {
		MassMailRecipient entity = this.loadMassMailRecipientFromEmailMessageVO(emailMessageVO);
		this.emailMessageVOToEntity(emailMessageVO, entity, true);
		return entity;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void emailMessageVOToEntity(
			EmailMessageVO source,
			MassMailRecipient target,
			boolean copyIfNull) {
		super.emailMessageVOToEntity(source, target, copyIfNull);
	}

	private MimeTypeVO getContentType(String mimeType) {
		MimeTypeDao mimeTypeDao = this.getMimeTypeDao();
		int paramsIndex = mimeType.indexOf(";");
		if (paramsIndex >= 0) {
			mimeType = mimeType.substring(0, paramsIndex);
		}
		Iterator<MimeType> it = mimeTypeDao.findByMimeTypeModule(mimeType, FileModule.MASS_MAIL_DOCUMENT).iterator();
		if (it.hasNext()) {
			return mimeTypeDao.toMimeTypeVO(it.next());
		}
		return null;
	}

	@Override
	protected Collection<MassMailRecipient> handleFindByDepartmentPending(Long departmentId, Timestamp now, Boolean pending, boolean scheduled, PSFVO psf)
			throws Exception {
		org.hibernate.Criteria recipientCriteria = createRecipientCriteria();
		SubCriteriaMap criteriaMap = new SubCriteriaMap(MassMailRecipient.class, recipientCriteria);
		if (departmentId != null) {
			criteriaMap.createCriteria("massMail").add(Restrictions.eq("department.id", departmentId.longValue()));
		}
		if (pending != null) {
			applyPendingCriteria(recipientCriteria, !pending);
		}
		if (scheduled) {
			criteriaMap.createCriteria("massMail.status").add(Restrictions.eq("sending", true));
			criteriaMap.createCriteria("massMail").add(Restrictions.le("start", now));
		}
		CriteriaUtil.applyPSFVO(criteriaMap, psf);
		return recipientCriteria.list();
	}

	@Override
	protected MassMailRecipient handleFindByMassMailProband(Long massMailId, Long probandId) throws Exception {
		org.hibernate.Criteria recipientCriteria = createRecipientCriteria();
		recipientCriteria.add(Restrictions.eq("massMail.id", massMailId.longValue()));
		recipientCriteria.add(Restrictions.eq("proband.id", probandId.longValue()));
		recipientCriteria.setMaxResults(1);
		return (MassMailRecipient) recipientCriteria.uniqueResult();
	}

	@Override
	protected Collection<MassMailRecipient> handleFindByMassMailProband(Long massMailId, Long probandId, PSFVO psf) throws Exception {
		org.hibernate.Criteria recipientCriteria = createRecipientCriteria();
		SubCriteriaMap criteriaMap = new SubCriteriaMap(MassMailRecipient.class, recipientCriteria);
		if (massMailId != null) {
			recipientCriteria.add(Restrictions.eq("massMail.id", massMailId.longValue()));
		}
		if (probandId != null) {
			recipientCriteria.add(Restrictions.eq("proband.id", probandId.longValue()));
		}
		CriteriaUtil.applyPSFVO(criteriaMap, psf);
		return recipientCriteria.list();
	}

	@Override
	protected Collection<MassMailRecipient> handleFindPending(Long massMailId, Long departmentId, Long probandDepartmentId, Timestamp now, boolean sort, PSFVO psf)
			throws Exception {
		org.hibernate.Criteria recipientCriteria = createRecipientCriteria();
		SubCriteriaMap criteriaMap = new SubCriteriaMap(MassMailRecipient.class, recipientCriteria);
		if (massMailId != null) {
			recipientCriteria.add(Restrictions.eq("massMail.id", massMailId.longValue()));
		}
		criteriaMap.createCriteria("massMail.status").add(Restrictions.eq("sending", true));
		criteriaMap.createCriteria("massMail").add(Restrictions.le("start", now));
		if (departmentId != null) {
			criteriaMap.createCriteria("massMail").add(Restrictions.eq("department.id", departmentId.longValue()));
		}
		if (probandDepartmentId != null) {
			criteriaMap.createCriteria("proband").add(Restrictions.eq("department.id", probandDepartmentId.longValue()));
		}
		applyPendingCriteria(recipientCriteria, false);
		if (sort) {
			if (psf == null) {
				psf = new PSFVO();
			}
			psf.setSortField("id");
			psf.setSortOrder(true);
		}
		CriteriaUtil.applyPSFVO(criteriaMap, psf);
		return recipientCriteria.list();
	}

	@Override
	protected long handleGetCount(Long massMailId, Long probandId, boolean pending) throws Exception {
		org.hibernate.Criteria recipientCriteria = createRecipientCriteria();
		if (massMailId != null) {
			recipientCriteria.add(Restrictions.eq("massMail.id", massMailId.longValue()));
		}
		if (probandId != null) {
			recipientCriteria.add(Restrictions.eq("proband.id", probandId.longValue()));
		}
		if (pending) {
			applyPendingCriteria(recipientCriteria, false);
		}
		return (Long) recipientCriteria.setProjection(Projections.rowCount()).uniqueResult();
	}

	/**
	 * Retrieves the entity object that is associated with the specified value object
	 * from the object store. If no such entity object exists in the object store,
	 * a new, blank entity is created
	 */
	private MassMailRecipient loadMassMailRecipientFromEmailMessageVO(EmailMessageVO emailMessageVO) {
		throw new UnsupportedOperationException("org.phoenixctms.ctsms.domain.loadMassMailRecipientFromEmailMessageVO(EmailMessageVO) not yet implemented.");
	}

	private MassMailRecipient loadMassMailRecipientFromMassMailRecipientInVO(MassMailRecipientInVO massMailRecipientInVO) {
		MassMailRecipient massMailRecipient = null;
		Long id = massMailRecipientInVO.getId();
		if (id != null) {
			massMailRecipient = this.load(id);
		}
		if (massMailRecipient == null) {
			massMailRecipient = MassMailRecipient.Factory.newInstance();
		}
		return massMailRecipient;
	}

	private MassMailRecipient loadMassMailRecipientFromMassMailRecipientOutVO(MassMailRecipientOutVO massMailRecipientOutVO) {
		MassMailRecipient massMailRecipient = this.get(massMailRecipientOutVO.getId());
		if (massMailRecipient == null) {
			massMailRecipient = MassMailRecipient.Factory.newInstance();
		}
		return massMailRecipient;
	}

	@Override
	public MassMailRecipient massMailRecipientInVOToEntity(MassMailRecipientInVO massMailRecipientInVO) {
		MassMailRecipient entity = this.loadMassMailRecipientFromMassMailRecipientInVO(massMailRecipientInVO);
		this.massMailRecipientInVOToEntity(massMailRecipientInVO, entity, true);
		return entity;
	}

	@Override
	public void massMailRecipientInVOToEntity(
			MassMailRecipientInVO source,
			MassMailRecipient target,
			boolean copyIfNull) {
		super.massMailRecipientInVOToEntity(source, target, copyIfNull);
		Long massMailId = source.getMassMailId();
		Long probandId = source.getProbandId();
		if (massMailId != null) {
			MassMail massMail = this.getMassMailDao().load(massMailId);
			target.setMassMail(massMail);
			massMail.addRecipients(target);
		} else if (copyIfNull) {
			MassMail massMail = target.getMassMail();
			target.setMassMail(null);
			if (massMail != null) {
				massMail.removeRecipients(target);
			}
		}
		if (probandId != null) {
			Proband proband = this.getProbandDao().load(probandId);
			target.setProband(proband);
			proband.addMassMailReceipts(target);
		} else if (copyIfNull) {
			Proband proband = target.getProband();
			target.setProband(null);
			if (proband != null) {
				proband.removeMassMailReceipts(target);
			}
		}
	}

	@Override
	public MassMailRecipient massMailRecipientOutVOToEntity(MassMailRecipientOutVO massMailRecipientOutVO) {
		MassMailRecipient entity = this.loadMassMailRecipientFromMassMailRecipientOutVO(massMailRecipientOutVO);
		this.massMailRecipientOutVOToEntity(massMailRecipientOutVO, entity, true);
		return entity;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void massMailRecipientOutVOToEntity(
			MassMailRecipientOutVO source,
			MassMailRecipient target,
			boolean copyIfNull) {
		super.massMailRecipientOutVOToEntity(source, target, copyIfNull);
		MassMailOutVO massMailVO = source.getMassMail();
		ProbandOutVO probandVO = source.getProband();
		UserOutVO modifiedUserVO = source.getModifiedUser();
		if (massMailVO != null) {
			MassMail massMail = this.getMassMailDao().massMailOutVOToEntity(massMailVO);
			target.setMassMail(massMail);
			massMail.addRecipients(target);
		} else if (copyIfNull) {
			MassMail massMail = target.getMassMail();
			target.setMassMail(null);
			if (massMail != null) {
				massMail.removeRecipients(target);
			}
		}
		if (probandVO != null) {
			Proband proband = this.getProbandDao().probandOutVOToEntity(probandVO);
			target.setProband(proband);
			proband.addMassMailReceipts(target);
		} else if (copyIfNull) {
			Proband proband = target.getProband();
			target.setProband(null);
			if (proband != null) {
				proband.removeMassMailReceipts(target);
			}
		}
		if (modifiedUserVO != null) {
			target.setModifiedUser(this.getUserDao().userOutVOToEntity(modifiedUserVO));
		} else if (copyIfNull) {
			target.setModifiedUser(null);
		}
	}

	public void setMassMailEmailSender(MassMailEmailSender massMailEmailSender) {
		this.massMailEmailSender = massMailEmailSender;
	}

	@Override
	public EmailMessageVO toEmailMessageVO(final MassMailRecipient entity) {
		return super.toEmailMessageVO(entity);
	}

	@Override
	public void toEmailMessageVO(
			MassMailRecipient source,
			EmailMessageVO target) {
		super.toEmailMessageVO(source, target);
		target.setSize(source.getMimeMessageSize());
		target.setTimestamp(source.getMimeMessageTimestamp());
		if (target.getSize() > 0l) {
			InputStream stream = null;
			try {
				if (!CoreUtil.isPassDecryption()) {
					throw new Exception();
				}
				stream = CryptoUtil.createDecryptionStream(source.getMimeMessageDataIv(), new ByteArrayInputStream(source.getEncryptedMimeMessageData()));
				MimeMessage mimeMessage = massMailEmailSender.getMailSender().createMimeMessage(stream);
				target.setSubject(mimeMessage.getSubject());
				Address[] to = mimeMessage.getRecipients(RecipientType.TO);
				target.getToAddresses().clear();
				if (to != null) {
					for (int i = 0; i < to.length; i++) {
						target.getToAddresses().add(internetAddressToEmailAddressVO((InternetAddress) to[i]));
					}
				}
				Address[] cc = mimeMessage.getRecipients(RecipientType.CC);
				target.getCcAddresses().clear();
				if (cc != null) {
					for (int i = 0; i < cc.length; i++) {
						target.getCcAddresses().add(internetAddressToEmailAddressVO((InternetAddress) cc[i]));
					}
				}
				Address[] bcc = mimeMessage.getRecipients(RecipientType.BCC);
				target.getBccAddresses().clear();
				if (bcc != null) {
					for (int i = 0; i < bcc.length; i++) {
						target.getBccAddresses().add(internetAddressToEmailAddressVO((InternetAddress) bcc[i]));
					}
				}
				Address[] from = mimeMessage.getFrom();
				target.getFromAddresses().clear();
				if (from != null) {
					for (int i = 0; i < from.length; i++) {
						target.getFromAddresses().add(internetAddressToEmailAddressVO((InternetAddress) from[i]));
					}
				}
				Address[] replyTo = mimeMessage.getReplyTo();
				target.getReplyToAddresses().clear();
				if (replyTo != null) {
					for (int i = 0; i < replyTo.length; i++) {
						target.getReplyToAddresses().add(internetAddressToEmailAddressVO((InternetAddress) replyTo[i]));
					}
				}
				Object content = mimeMessage.getContent();
				target.setText(null);
				target.getAttachments().clear();
				if (content instanceof Multipart) {
					Multipart multiPart = (Multipart) content;
					for (int i = 0; i < multiPart.getCount(); i++) {
						MimeBodyPart messageBodyPart = (MimeBodyPart) multiPart.getBodyPart(i);
						if (Part.ATTACHMENT.equalsIgnoreCase(messageBodyPart.getDisposition())) {
							// this part is attachment
							// code to save attachment...
							DataHandler handler = messageBodyPart.getDataHandler();
							byte[] data = CommonUtil.inputStreamToByteArray(handler.getInputStream());
							target.getAttachments().add(new EmailAttachmentVO(data, handler.getName(), (long) data.length, getContentType(handler.getContentType())));
						} else {
							target.setText(messageBodyPart.getContent().toString());
						}
					}
				} else {
					target.setText(content.toString());
				}
				target.setDecrypted(true);
			} catch (MessagingException e) {
				throw new RuntimeException(e);
			} catch (IOException e) { // covered by MessagingException, but not handler.getInputStream()
				throw new RuntimeException(e);
			} catch (Exception e) {
				target.setSubject(null);
				target.setText(null);
				target.getFromAddresses().clear();
				target.getReplyToAddresses().clear();
				target.getToAddresses().clear();
				target.getCcAddresses().clear();
				target.getBccAddresses().clear();
				target.getAttachments().clear();
				target.setDecrypted(false);
			} finally {
				if (stream != null) {
					try {
						stream.close();
					} catch (IOException e1) {
					}
				}
			}
		}
	}

	@Override
	public MassMailRecipientInVO toMassMailRecipientInVO(final MassMailRecipient entity) {
		return super.toMassMailRecipientInVO(entity);
	}

	@Override
	public void toMassMailRecipientInVO(
			MassMailRecipient source,
			MassMailRecipientInVO target) {
		super.toMassMailRecipientInVO(source, target);
		MassMail massMail = source.getMassMail();
		Proband proband = source.getProband();
		if (massMail != null) {
			target.setMassMailId(massMail.getId());
		}
		if (proband != null) {
			target.setProbandId(proband.getId());
		}
	}

	@Override
	public MassMailRecipientOutVO toMassMailRecipientOutVO(final MassMailRecipient entity) {
		return super.toMassMailRecipientOutVO(entity);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void toMassMailRecipientOutVO(
			MassMailRecipient source,
			MassMailRecipientOutVO target) {
		super.toMassMailRecipientOutVO(source, target);
		MassMail massMail = source.getMassMail();
		Proband proband = source.getProband();
		User modifiedUser = source.getModifiedUser();
		if (massMail != null) {
			target.setMassMail(this.getMassMailDao().toMassMailOutVO(massMail));
		}
		if (proband != null) {
			target.setProband(this.getProbandDao().toProbandOutVO(proband));
		}
		if (modifiedUser != null) {
			target.setModifiedUser(this.getUserDao().toUserOutVO(modifiedUser));
		}
		target.setHasMimeMessage(source.getMimeMessageSize() > 0l);
		target.setPending(ServiceUtil.isMassMailRecipientPending(source));
	}
}